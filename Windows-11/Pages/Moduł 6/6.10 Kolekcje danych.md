# 6.10 Kolekcje danych

## Wprowadzenie

Kolekcje danych to struktury, które przechowują wiele elementów, takich jak liczby, ciągi znaków czy obiekty.  
_**PowerShell**_ oferuje różne typy kolekcji, takie jak **tablice**, **listy** i **słowniki**, które są niezbędne do przechowywania i przetwarzania danych w skryptach.

-----

### Podstawowa składnia

| Operacja | Opis |
| :--- | :--- |
| `Add` | Dodaje element do `ArrayList` lub parę klucz-wartość do `Hashtable`. |
| `Remove` | Usuwa element z `ArrayList` lub parę z `Hashtable`. |
| `foreach` | Iteruje po elementach kolekcji. |
| `Where-Object` | Filtruje elementy kolekcji na podstawie warunku. |
| `Sort-Object` | Sortuje elementy kolekcji. |


### Typy kolekcji

| Typ kolekcji | Opis | Przykład |
| :--- | :--- | :--- |
| **Tablica (Array)** | Statyczna lista elementów, np. imion. | `$tablica = "Adam", "Ewa"` |
| **Lista (ArrayList)** | Dynamiczna lista, do której można dodawać lub usuwać elementy. | `$lista = New-Object System.Collections.ArrayList` |
| **Słownik (Hashtable)** | Zestaw par klucz-wartość, np. imię i wiek. | `$slownik = @{ "Joana" = 30 }` |

-----

## Tablica

**Tablica** to najprostsza struktura, która przechowuje zbiór elementów tego samego typu.

### Przykład: Funkcja wyświetlająca zawartość tablicy

Poniższy skrypt pokazuje, jak napisać funkcję, która wyświetla zawartość tablicy, jednocześnie sprawdzając, czy nie jest ona pusta, i obsługuje potencjalny błąd za pomocą `try-catch`.

```powershell
function Show-Table-Content {
    param($tablicaImion)
    try {
        if (-not $tablicaImion) {
            throw "Tablica imion jest pusta!"
        }
        Write-Output "Lista imion:"
        # Iteracja po elementach tablicy ($tablicaImion) za pomocą zmiennej $imie.
        foreach ($imie in $tablicaImion) {
            Write-Output $imie
        }
    }catch {
        Write-Error "Błąd: $($_.Exception.Message)"
    }
}
# Przykład z pustą tablicą
$tablicaImion
Show-Table-Content -tablicaImion $tablicaImion
# Przykład z danymi
$tablicaImion = "Janek", "Ania", "Kamil"
Show-Table-Content -tablicaImion $tablicaImion

Read-Host "Wciśnij Enter, by zakończyć."
```
![Wynik komendy tablicy](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-Array-Basic.webp)

<div data-hint="info">

**Indeksy**: Elementy tablicy mają numery (*indeksy*), które zaczynają się od **$$0$$**. Na przykład `$imiona[0]` to `"Janek"`, a `$imiona[1]` to `"Ania"`.

</div>

### Modyfikacja elementów tablicy

Tablice są statyczne, co oznacza, że aby dodać lub usunąć element, trzeba stworzyć nową tablicę, która będzie zawierać zmodyfikowaną zawartość.

```powershell
$tablica = "Janek", "Ania", "Kamil"
$tablica = $tablica + "Magdalena"

Write-Output $tablica

Read-Host "Wciśnij Enter, by zakończyć."
```

W przypadku usuwania, należy w pętli przeiterować przez elementy i przypisać do nowej tablicy tylko te, które mają zostać zachowane.

```powershell
$tablica = "Janek", "Ania", "Kamil"

# Deklaracja pustej tablicy (array)
$nowaTablica = @()

foreach ($imie in $tablica) {
    # Sprawdzenie, czy element nie ma wartości "Ania", a następnie przypisanie go do nowej tablicy
    if($imie -ne "Ania"){
        $nowaTablica += $imie
    }
}
# Wyświetlenie nowej tablicy
Write-Output $nowaTablica
Read-Host "Wciśnij Enter, by zakończyć."
```

-----

## `ArrayList` - Dynamiczne tablice

Zamiast pisać skomplikowaną implementację do modyfikacji statycznej tablicy, możesz skorzystać z jej dynamicznej alternatywy, jaką jest `ArrayList`.

Poniższy przykład pokazuje, jak stworzyć listę użytkowników, a następnie dodawać i usuwać z niej elementy.

```powershell
# Nowa pusta dynamiczna tablica ArrayList
$lista = New-Object System.Collections.ArrayList

Write-Output "-----------------------------------"
Write-Output "Dodawanie imion"
# Dodawanie imion
$lista.Add("Janek")
$lista.Add("Ania")
$lista.Add("Kamil") | Out-Null
$lista.Add("Magdalena") | Out-Null

Write-Output "-----------------------------------"
Write-Output "Lista użytkowników:"
foreach ($uzytkownik in $lista) {
    Write-Output $uzytkownik
}

# Usuniecie Ani i Janka z listy imion
$lista.Remove("Ania")
$lista.Remove("Janek") | Out-Null

Write-Output "-----------------------------------"

Write-Output "Po usunięciu Ani i Janka:"
foreach ($uzytkownik in $lista) {
    Write-Output $uzytkownik
}

Read-Host "Wciśnij Enter, by zakończyć."
```

<div data-hint="success">

`Out-Null` w metodzie `Add` zapobiega wyświetlaniu indeksu dodanego elementu, co sprawia, że wynik jest czytelniejszy.

</div>

![Wynik komendy ArrayList](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-ArrayList-Basic.webp)


## Słowniki z `Hashtable`

**Hashtable** to kolekcja, która przechowuje pary `klucz`-`wartość`, np. imię użytkownika i jego wiek lub rola. Jest idealna do przechowywania powiązanych danych.

### Przykład: Role użytkowników

Stwórzmy słownik przechowujący role użytkowników w systemie.

```powershell
# Tworzenie Hashtable
$role = @{ "Janek" = "Admin"; "Ania" = "Użytkownik"; "Kamil" = "Gość" }
Write-Output "-----------------------------------"
Write-Output "Role użytkowników:"
$role.GetEnumerator() | Sort-Object Name | ForEach-Object { Write-Output "$($_.Key): $($_.Value)" }

# Dodawanie i usuwanie kluczy
$role.Add("Ewa", "Redaktor")
$role.Remove("Kamil")

Write-Output "-----------------------------------"
Write-Output "Po dodaniu Ewy i usunięciu Kamila:"
$role.GetEnumerator() | Sort-Object Name | ForEach-Object { Write-Output "$($_.Key): $($_.Value)" }

Read-Host "Wciśnij Enter, by zakończyć."
```

<div data-hint="info">

`GetEnumerator()` pozwala iterować po parach klucz-wartość w `Hashtable`.

</div>

![Wynik komendy Hashtable](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-Hashtable-Basic.webp)


## Filtrowanie i sortowanie kolekcji

Kolekcje można łatwo przetwarzać, np. wybierać tylko określone elementy lub sortować je.  
Użyjemy do tego poleceń `Where-Object` i `Sort-Object`.

### Przykład: Filtrowanie imion

Wybierzmy imiona kończące się na literę "*`a`*" i posortujmy je alfabetycznie.

```powershell
$imiona = "Janek", "Ania", "Kamil", "Ewa"
$imiona | Where-Object { $_ -like "*a" } | Sort-Object
Read-Host "Wciśnij Enter, by zakończyć."
```

![Wynik komendy filtrowania](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-Filter-Sort-Basic.webp)


## Przykład: Sprawdzanie użytkowników

Połączmy kolekcje z poleceniem `Get-LocalUser`, aby sprawdzić, którzy użytkownicy z listy istnieją w systemie.

```powershell
$users = "Administrator", "Janek", "Ania", "Gość"
foreach ($user in $users) {
    if (Get-LocalUser -Name $user -ErrorAction SilentlyContinue) {
        Write-Output "$user istnieje!"
    } else {
        Write-Output "$user nie istnieje!"
    }
}
```
![Wynik komendy sprawdzania użytkowników](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-Check-Users-Basic.webp)

<div data-hint="success">

Polecenie `Get-LocalUser -ErrorAction SilentlyContinue` sprawia, że skrypt nie wyświetla błędów (np. gdy użytkownik nie istnieje) i kontynuuje działanie.

</div>

### Wartości `-ErrorAction`

| Wartość | Co robi? |
| :--- | :--- |
| `Continue` (domyślna) | Pokaż błąd i kontynuuj. |
| `Stop` | Zatrzymaj skrypt przy błędzie. |
| `SilentlyContinue` | Nie pokazuj błędu, kontynuuj. |
| `Ignore` | Ignoruj błąd całkowicie. |
| `Inquire` | Zapytaj użytkownika, co zrobić. |

---

# Podcast AI

<audio src="https://raw.githubusercontent.com/Edu-Koala-V/audio_podcast/refs/heads/main/Windows_11/Audio/PowerShell_ Mastering Data Collections, Arrays, Lists, and Hashtables.wav" controls>
Twoja przeglądarka nie wspiera odtwarzania plików audio.
</audio>