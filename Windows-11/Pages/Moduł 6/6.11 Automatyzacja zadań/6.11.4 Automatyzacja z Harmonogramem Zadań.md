# 6.11.4: Automatyzacja z Harmonogramem Zada

## Wprowadzenie

Dokonamy kolejnej, a zarazem ostatniej, refaktoryzacji naszego automatycznego skryptu do usuwania przestarzaych plik贸w.

## Pozbycie si komunikat贸w interakcyjnych

Dla penej automatyzacji dokonamy kilku zmian. Po pierwsze, bdziemy z automatu potwierdza poni偶szy komunikat:

![Komunikat pytajcy o potwierdzenie zawartoci wskazanego katalogu](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-komunikat-potwierdzenia.webp)


Problemem jest ta linia:

```powershell
    # Usunicie pliku lub katalogu
    Remove-Item -Path $res.FullName -Force -ErrorAction Stop
```

Poprawmy j, oddzielajc usuwanie plik贸w od katalog贸w z zawartoci. To poprawi czytelno i mo偶e pozytywnie wpyn na wydajno.

Sprawdzimy, czy element, kt贸ry chcemy usun, jest katalogiem (`.PSIsContainer`). W zale偶noci od spenienia warunku, dla przypadku katalogu z zawartoci dopiszemy argument `-Recurse`.  
  
Oczywicie, aby nie pojawia si komunikat o potwierdzenie, zmienimy warto dla `-ErrorAction` ze `Stop` na `SilentlyContinue`, kt贸re znasz z lekcji **$$6.10$$ Kolekcje danych**.

```powershell
   # Usunicie katalogu z zawartoci lub pliku
   if ($res.PSIsContainer) {
        Remove-Item -Path $res.FullName -Force -Recurse -ErrorAction SilentlyContinue
        Write-Host "Usuwanie katalogu $res.FullName"
   } else {
        Remove-Item -Path $res.FullName -Force -ErrorAction SilentlyContinue
        Write-Host "Usuwanie pliku $res.FullName"
   }
```

Dodatkowo, usu wywoanie `Read-Host` z g贸wnego skryptu.

## Funkcjonalnoci tylko w trybie interakcyjnym

Je偶eli chcemy w peni zautomatyzowany skrypt, to nie mo偶e nam pojawia si okienko z podsumowaniem. Jednak chcemy je zachowa, gdy rcznie uruchomimy skrypt. Mo偶esz ten przypadek sprawdzi przy pomocy `[Environment]::UserInteractive` w `IF`.

```powershell
# Wywietlenie okienka systemowego (tylko jeli sesja jest interaktywna)
if ([Environment]::UserInteractive) {
    $Message = "Czyszczenie systemu zakoczone.`nZwolniono $totalFreedSpaceMB MB miejsca na dysku."
    [System.Windows.Forms.MessageBox]::Show($Message, "Czyszczenie systemu", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)

    Write-Host "Skrypt zakoczy dziaania. "
    # Opcjonalne oczekiwanie na Enter
    Read-Host "Wcinij Enter, aby zakoczy dziaanie."
}
```

## Zautomatyzowanie tworzenia nowego zadania w `taskschd.msc`

Dodamy nowy skrypt (`Add-Clean-Task.ps1`), kt贸ry utworzy zadanie w Harmonogramie Zada, aby automatycznie uruchamia `CleanOldResources.ps1`.

Oto skrypt do tworzenia zadania (`C:\Scripts\Create-Task.ps1`):

```powershell
# Sprawdzenie uprawnie administracyjnych
if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(
           [Security.Principal.WindowsBuiltInRole] "Administrator")) {
    $BypassExecute = "-ExecutionPolicy Bypass -File " + '"' + $PSCommandPath + '"'
    Start-Process powershell $BypassExecute -Verb RunAs
    exit
}
#-----------------------------------------------------------------------------------------------------------------------------------------------------#
# Parametry zadania
#-----------------------------------------------------------------------------------------------------------------------------------------------------#
# Nazwa zadania i jego opis
$TaskName = "MyCustom_CleanOldResourcesTask"
$TaskDescription = "Automatyczne czyszczenie starych plik贸w systemowych"

# Lokalizacja skryptu do uruchomienia
$ScriptPath = "C:\Scripts\CleanOldResources.ps1"

# Okrelenie wyzwalacza uruchomienia zadania (W ka偶d rod i niedziel o 10:00 rano)
$Trigger = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Wednesday,Sunday -At "10:00"

# Zdefiniowanie czynnoci do zrobienia, w tym przypadku uruchomienie PowerShell-a i w nim skryptu z lokalizacji.
$Action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -ExecutionPolicy Bypass -File `"$ScriptPath`""

# Nadanie poziomu uprawnie konta "SYSTEM" do uruchomienia zadania.
$Principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest


#-----------------------------------------------------------------------------------------------------------------------------------------------------#
# Tworzenie zadania
#-----------------------------------------------------------------------------------------------------------------------------------------------------#
try {
    Register-ScheduledTask -TaskName $TaskName -Description $TaskDescription -Action $Action -Trigger $Trigger -Principal $Principal -ErrorAction Stop
    Write-Host "Zadanie '$TaskName' zostao utworzone pomylnie."
}
catch {
    Write-Host "Bd podczas tworzenia zadania: $($_.Exception.Message)"
}

#-----------------------------------------------------------------------------------------------------------------------------------------------------#
# Opcjonalne oczekiwanie na Enter (tylko przy rcznym uruchamianiu)
if ([Environment]::UserInteractive) {
    Read-Host "Wcinij Enter, aby zakoczy."
}
```

### Parametry dla wyzwalacza `New-ScheduledTaskTrigger`

| Parametr | Opis | Przykad |
| :--- | :--- | :--- |
| `-At <DateTime>` | Okrela dokadny czas uruchomienia zadania </br>(data i/lub godzina). | `-At "2025-07-13 02:00"` |
| `-Daily` | Uruchamia zadanie codziennie o okrelonej godzinie. | `-Daily -At "03:00"` |
| `-Weekly` | Uruchamia zadanie co tydzie w wybrane dni tygodnia. | `-Weekly -DaysOfWeek Niedziela -At "02:00"` |
| `-DaysOfWeek <String[]>` | Okrela dni tygodnia, w kt贸re zadanie ma si uruchomi. | `-Weekly -DaysOfWeek Wednesday,Sunday -At "02:00"` |
| `-WeeksInterval <Int32>` | Okrela, co ile tygodni zadanie ma si uruchomi. | `-Weekly -DaysOfWeek Sunday -At "2:00" -WeeksInterval 2` |
| `-Once` | Uruchamia zadanie tylko raz w okrelonym czasie. | `-Once -At "2025-07-13 2:00AM"` |
| `-AtStartup` | Uruchamia zadanie przy starcie systemu. | `-AtStartup` |
| `-AtLogon` | Uruchamia zadanie przy logowaniu u偶ytkownika. | `-AtLogon -User "Koala"` |
| `-RandomDelay <TimeSpan>` | Dodaje losowe op贸藕nienie do czasu uruchomienia. | `-Daily -At "3:00AM" -RandomDelay "00:30:00"` |

Od $$08:00$$ co godzin przez $$8$$ godzin, czyli do $$16:00$$:
`-Daily -At "8:00AM" -RepetitionInterval "01:00:00" -RepetitionDuration "08:00:00"`

  - `-RepetitionInterval <TimeSpan>`: Okrela, jak czsto zadanie ma si powtarza w ramach jednego wyzwalacza.
  - `-RepetitionDuration <TimeSpan>`: Okrela, jak dugo zadanie ma si powtarza.

### Dni tygodnia

| EN | PL |
| :--- | :--- |
| Monday | Poniedziaek |
| Tuesday | Wtorek |
| Wednesday | roda |
| Thursday | Czwartek |
| Friday | Pitek |
| Saturday | Sobota |
| Sunday | Niedziela |

# Uruchomienie dodania nowego zadania

Po uruchomieniu skryptu `Add-Clean-Task.ps1` zobaczysz komunikat o dodaniu nowego zadania:

![Uruchomienie dodania nowego zadania](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/powershell-add-new-task.webp)

W `taskschd.msc` pojawio si nasze nowe zadanie:

![Nowe zadanie w taskschd.msc](https://raw.githubusercontent.com/Edu-Koala-V/images/main/Windows_11/Images/taskschd.msc-nowe-zadanie-z-powershell.webp)

---

# Podcast AI

<audio src="https://raw.githubusercontent.com/Edu-Koala-V/audio_podcast/refs/heads/main/Windows_11/Audio/Automating Tasks with the Task Scheduler.wav" controls>
Twoja przegldarka nie wspiera odtwarzania plik贸w audio.
</audio>