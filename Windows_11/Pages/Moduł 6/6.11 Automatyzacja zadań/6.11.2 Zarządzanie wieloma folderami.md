# 6.11.2: Zarzdzanie wieloma folderami

## Wprowadzenie

Zmodyfikujemy nasz *main* skrypt, aby wykorzystywa lokalizacje katalog贸w do czyszczenia z zewntrznego pliku tekstowego i wywoywa na nich funkcj `Remove-OldFiles`.

## Struktura pliku konfiguracyjnego

Stworzymy plik tekstowy (np. `CleanupFolders.txt`) zawierajcy list folder贸w do czyszczenia.  
Ka偶da linia pliku bdzie zawieraa jedn cie偶k.

```txt
C:\Windows\Temp
%TEMP%
C:\Windows\SoftwareDistribution\Download
C:\Windows\Prefetch
C:\Users\%USERNAME%\AppData\Local\Microsoft\Windows\INetCache
C:\$Recycle.Bin
C:\Users\%USERNAME%\Downloads
```

  - `%TEMP%` i `%USERNAME%` to zmienne rodowiskowe, kt贸re _**PowerShell**_ mo偶e rozwin za pomoc `Expand-EnvironmentVariables`.
  - cie偶ki z `%USERNAME%` dynamicznie podstawiaj nazwy bie偶cego u偶ytkownika.
  - Kosz (`C:\$Recycle.Bin`) wymaga specjalnego traktowania, poniewa偶 zawiera podfoldery dla ka偶dego u偶ytkownika (*`SID`*).

## Refaktoryzacja aktualnego kodu

Zanim dodamy funkcjonalno iterowania po lokalizacjach z pliku tekstowego, najpierw przepiszmy nasz aktualny kod, aby by czytelniejszy i atwiejszy w konfiguracji.

Na samym pocztku zapiszemy warunek `IF` weryfikujcy, czy skrypt zosta uruchomiony z podwy偶szonymi uprawnieniami Administratora, czyli aby uruchomi nam si **UAC** (*User Account Control*).

```powershell
# Sprawdzenie uprawnie administracyjnych
if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(
      [Security.Principal.WindowsBuiltInRole] "Administrator")) {
  $BypassExecute = "-ExecutionPolicy Bypass -File " + '"' + $PSCommandPath + '"'
  Start-Process powershell $BypassExecute -Verb RunAs
  exit
}
```

Teraz zapiszmy nasz fragment konfiguracyjny skryptu. Na sekcje importowania plik贸w `.ps1` i zmienne globalne z lokalizacjami dodatkowych plik贸w i iloci dni.

```powershell
# Importowanie funkcji z pliku CleanupFunctions.ps1
. "C:\Scripts\CleanupFunctions.ps1"

# cie偶ka do pliku konfiguracyjnego
$ConfigFile = "C:\Scripts\CleanupFolders.txt"
$LogFile = "C:\Logs\CleanFolders.log"
$Days = 30
```

Pamitaj, aby utworzy standardowo lokalizacj `C:\Logs\`.  
Przesyanie parametr贸w do funkcji `Remove-OldFiles` zostao teraz troch usprawnione i uproszczone wykorzystujc zmienne `$Days` i `$LogFile`.

```powershell
# Tworzenie katalogu log贸w, jeli nie istnieje
New-Item -Path "C:\Logs" -ItemType Directory -Force | Out-Null

# Wywoanie funkcji Remove-OldFiles dla ka偶dego folderu
Remove-OldFiles -FolderPath "C:\Windows\Temp" -Days $Days -LogFile $LogFile
```

## Pobieranie danych z pliku tekstowego

Na pocztek sprawdzimy, czy plik tekstowy w lokalizacji z globalnej zmiennej `$ConfigFile` istnieje.

```powershell
# Sprawdzenie, czy plik konfiguracyjny istnieje
if (-not (Test-Path $ConfigFile)) {
  Write-Log -Message "Bd: Plik konfiguracyjny $ConfigFile nie istnieje!" -LogFile $LogFile
  Read-Host "Wcinij Enter, aby zakoczy."
  exit
}
```

Skoro jestemy pewni, 偶e plik ze cie偶kami istnieje, to przy u偶yciu `Get-Content` zapiszmy jego linie jako kolekcj element贸w (tablica string贸w).

```powershell
# Wczytanie listy folder贸w z pliku konfiguracyjnego
$Folders = Get-Content -Path $ConfigFile
```

Nasze cie偶ki w pliku tekstowym zawieraj zmienne rodowiskowe, kt贸re bdzie trzeba rozbi na faktyczn lokalizacj katalog贸w. Wykorzystaj do tego: 
```powershell
[System.Environment]::ExpandEnvironmentVariables([Lokalizacja zawierajca zmienne rodowiskowe do rozbicia.])
```

Przeiteruj przez ka偶dy element tablicy za pomoc `foreach`, w razie wykorzystania zmiennej rodowiskowej rozbij j i usu wszystkie katalogi oraz pliki starsze ni偶 podana warto w `$Days`.

```powershell
# Przetwarzanie ka偶dego folderu
foreach ($Folder in $Folders) {
  # Rozwinicie zmiennych rodowiskowych w cie偶ce (np. %TEMP%, %USERNAME%)
  $ExpandedFolder = [System.Environment]::ExpandEnvironmentVariables($Folder)
  
  # Logowanie rozpoczcia czyszczenia folderu
  Write-Log -Message "Rozpoczynanie czyszczenia folderu: $ExpandedFolder" -LogFile $LogFile
  
  # Wywoanie funkcji Remove-OldFiles dla ka偶dego folderu
  Remove-OldFiles -FolderPath $ExpandedFolder -Days $Days -LogFile $LogFile
}

Write-Host "Skrypt zakoczy dziaania. "
# Opcjonalne oczekiwanie na Enter
Read-Host "Wcinij Enter, aby zakoczy dziaanie."
```

### Dodatkowe ulepszenia (opcjonalne)

  - **Walidacja cie偶ek**: Dodaj sprawdzanie, czy ka偶da cie偶ka w pliku konfiguracyjnym jest poprawna przed wywoaniem `Remove-OldFiles`.
  - **Obsuga wielu u偶ytkownik贸w**: Rozszerz skrypt, aby dynamicznie przetwarza foldery wszystkich u偶ytkownik贸w w `C:\Users`.
  - **Parametryzacja dni**: Umo偶liw u偶ytkownikowi podanie liczby dni jako parametr skryptu (np. przez `param` lub `$args`), albo po prostu zapytaj go o to. 

---

# Podcast AI

<audio src="https://raw.githubusercontent.com/Edu-Koala-V/audio_podcast/refs/heads/main/Windows_11/Audio/PowerShell Folder Cleanup with Configuration File.wav" controls>
Twoja przegldarka nie wspiera odtwarzania plik贸w audio.
</audio>